# 数据结构和算法

## 01 将序列分解为单独的变量

任何的序列（或者是可迭代对象）可以通过一个简单的赋值操作来分解为单独的变量。 唯一的要求就是变量的总数和结构必须与序列相吻合。

不仅仅只是元组或列表，只要对象是可迭代的，就可以执行分解操作。包括字符串，文件对象，迭代器和生成器。

!!! tips
    如果只想使用部分变量，可以将不需要的变量用占位符如 `_` 替代。

```python 
>>> data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
>>> _, shares, price, _ = data
>>> shares
50
>>> price
91.1
>>>
```

## 02 解压可迭代对象赋值给多个变量

如果一个可迭代对象的元素个数超过变量个数时，会抛出一个 `ValueError`。 

此时，可以分析要处理的数据结构，将变动的部分，用星号表达式 `*` 处理。其中，用 `*`代替的变量类型始终为 list，即使 list 长度为 0。

```python
# 假设现在有一些用户的记录列表，每条记录包含一个名字、邮件，接着就是不确定数量的电话号码。
>>> record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
>>> name, email, *phone_numbers = record
>>> name
'Dave'
>>> email
'dave@example.com'
>>> phone_numbers
['773-555-1212', '847-555-1212']
>>>
```

!!! tip
    **星号表达式可以用在可迭代对象的开头，中间，或结尾，以及结合占位符用于嵌套的结构。**

    扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。 通常，这些可迭代对象的元素结构有确定的规则（比如第 1 个元素后面都是电话号码）， 星号表达式让开发人员可以很容易的利用这些规则来解压出元素来。 

### 星号表达式的常用场景

- 迭代元素为可变长元组的序列

```python
records = [
    ('foo', 1, 2),
    ('bar', 'hello'),
    ('foo', 3, 4),
]

def do_foo(x, y):
    print('foo', x, y)

def do_bar(s):
    print('bar', s)

for tag, *args in records:
    if tag == 'foo':
        do_foo(*args)
    elif tag == 'bar':
        do_bar(*args)
```

- 字符串的分割

```python
>>> line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'
>>> uname, *fields, homedir, sh = line.split(':')
```

- 结合占位符，如 `_` 或 `ign`（ignore），丢弃不需要的元素

```python
>>> record = ('ACME', 50, 123.45, (12, 18, 2012))
>>> name, *_, (*_, year) = record
```

- 列表的分割

```python
>>> items = [1, 10, 7, 4, 5, 9]
>>> head, *tail = items
```

## 03 保留最后N个元素

在迭代操作或者其他操作的时候，可以使用 `collections.deque` 来实现只保留最后有限几个元素的历史记录。

使用 `deque(maxlen=N)` 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。

相对于手动在一个列表上实现这一的操作（比如增加、删除等等）。使用 `collections.deque` 会更加优雅并且运行得更快。

`deque` 类可以被用在任何只需要一个简单队列数据结构的场合，并且可以在队列的两端执行添加和弹出元素的操作。

```python
from collections import deque
>>> q = deque()
>>> q.append(1)
>>> q.append(2)
>>> q.append(3)
>>> q
deque([1, 2, 3])
>>> q.appendleft(4)
>>> q
deque([4, 1, 2, 3])
>>> q.pop()
3
>>> q
deque([4, 1, 2])
>>> q.popleft()
4

```

!!! note
    在队列两端插入或删除元素时间复杂度都是 O(1) ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 O(N)。

## 04 查找最大或最小的N个元素

使用 `heapq` 模块的两个函数：`nlargest()` 和 `nsmallest()` 可以从一个集合中获得最大或者最小的 N 个元素列表。


## 05 实现一个优先级队列

## 06 字典中的键映射多个值

## 07 字典排序

## 08 字典的运算

## 09 查找两字典的相同点

## 10 删除序列相同元素并保持顺序

## 11 命名切片
 
## 12 序列中出现次数最多的元素

## 13 通过某个关键字排序一个字典列表

## 14 排序不支持原生比较的对象

## 15 通过某个字段将记录分组

## 16 过滤序列元素

## 17 从字典中提取子集

## 18 映射名称到序列元素

## 19 转换并同时计算数据

## 20 合并多个字典或映射

## 总结