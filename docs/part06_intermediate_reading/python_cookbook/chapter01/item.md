# 数据结构和算法
<!-- -------------------------------------------------------------------------- -->
## 01 将序列分解为单独的变量

!!! question "问题"
    有一个包含 N 个元素的元组或者是序列，怎样将它里面的值解压后同时赋值给 N 个变量？

??? done "解决方案"
    任何的序列（或者是可迭代对象）可以通过一个简单的赋值操作来分解为单独的变量。 **唯一的要求就是变量的总数和结构必须与序列相吻合。**

    不仅仅只是元组或列表，只要对象是可迭代的，就可以执行分解操作。包括字符串，文件对象，迭代器和生成器。

??? summary "讨论"
    如果只想使用部分变量，可以将不需要的变量用占位符如 `_` 替代。

    ```python 
    >>> data = [ 'ACME', 50, 91.1, (2012, 12, 21) ]
    >>> _, shares, price, _ = data
    >>> shares
    50
    >>> price
    91.1
    >>>
    ```
<!-- -------------------------------------------------------------------------- -->
## 02 解压可迭代对象赋值给多个变量

!!! question "问题"
    如果一个可迭代对象的元素个数超过变量个数时，会抛出一个 `ValueError`。 那么怎样才能从这个可迭代对象中解压出 N 个元素出来？

??? done "解决方案"
    此时，可以分析要处理的数据结构，将变动的部分，用星号表达式 `*` 处理。其中，用 `*`代替的变量类型始终为 list，即使 list 长度为 0。

    ```python
    # 假设现在有一些用户的记录列表，每条记录包含一个名字、邮件，接着就是不确定数量的电话号码。
    >>> record = ('Dave', 'dave@example.com', '773-555-1212', '847-555-1212')
    >>> name, email, *phone_numbers = record
    >>> name
    'Dave'
    >>> email
    'dave@example.com'
    >>> phone_numbers
    ['773-555-1212', '847-555-1212']
    >>>
    ```

??? summary "讨论"
    **星号表达式可以用在可迭代对象的开头，中间，或结尾，以及结合占位符用于嵌套的结构。**

    扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。 通常，这些可迭代对象的元素结构有确定的规则（比如第 1 个元素后面都是电话号码）， 星号表达式让开发人员可以很容易的利用这些规则来解压出元素来。 

    ### 星号表达式的常用场景

    - 迭代元素为可变长元组的序列

    ```python
    records = [
        ('foo', 1, 2),
        ('bar', 'hello'),
        ('foo', 3, 4),
    ]

    def do_foo(x, y):
        print('foo', x, y)

    def do_bar(s):
        print('bar', s)

    for tag, *args in records:
        if tag == 'foo':
            do_foo(*args)
        elif tag == 'bar':
            do_bar(*args)
    ```

    - 字符串的分割

    ```python
    >>> line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'
    >>> uname, *fields, homedir, sh = line.split(':')
    ```

    - 结合占位符，如 `_` 或 `ign`（ignore），丢弃不需要的元素

    ```python
    >>> record = ('ACME', 50, 123.45, (12, 18, 2012))
    >>> name, *_, (*_, year) = record
    ```

    - 列表的分割

    ```python
    >>> items = [1, 10, 7, 4, 5, 9]
    >>> head, *tail = items
    ```
<!-- -------------------------------------------------------------------------- -->
## 03 保留最后N个元素

!!! question "问题"
    在迭代操作或者其他操作的时候，怎样只保留最后有限几个元素的历史记录？

??? done "解决方案"
    在迭代操作或者其他操作的时候，可以使用 `collections.deque` 来实现只保留最后有限几个元素的历史记录。

??? summary "讨论"
    使用 `deque(maxlen=N)` 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候， 最老的元素会自动被移除掉。

    相对于手动在一个列表上实现这一的操作（比如增加、删除等等）。使用 `collections.deque` 会更加优雅并且运行得更快。

    `deque` 类可以被用在任何只需要一个简单队列数据结构的场合，并且可以在队列的两端执行添加和弹出元素的操作。

    ```python
    from collections import deque
    >>> q = deque()
    >>> q.append(1)
    >>> q.append(2)
    >>> q.append(3)
    >>> q
    deque([1, 2, 3])
    >>> q.appendleft(4)
    >>> q
    deque([4, 1, 2, 3])
    >>> q.pop()
    3
    >>> q
    deque([4, 1, 2])
    >>> q.popleft()
    4
    ```

    在队列两端插入或删除元素时间复杂度都是 O(1) ，区别于列表，在列表的开头插入或删除元素的时间复杂度为 O(N)。

<!-- -------------------------------------------------------------------------- -->
## 04 查找最大或最小的N个元素

!!! question "问题"
    怎样从一个集合中获得最大或者最小的 N 个元素列表？

??? done "解决方案"
    使用 `heapq` 模块的两个函数：`nlargest()` 和 `nsmallest()`。

    **除了基本用法，两个函数都能接受一个关键字参数，用于更复杂的数据结构中**
    ```python
        portfolio = [
        {'name': 'IBM', 'shares': 100, 'price': 91.1},
        {'name': 'AAPL', 'shares': 50, 'price': 543.22},
        {'name': 'FB', 'shares': 200, 'price': 21.09},
        {'name': 'HPQ', 'shares': 35, 'price': 31.75},
        {'name': 'YHOO', 'shares': 45, 'price': 16.35},
        {'name': 'ACME', 'shares': 75, 'price': 115.65}
    ]
    cheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])
    expensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])
    ```

??? summary "讨论"
    堆数据结构最重要的特征是 heap[0] 永远是最小的元素。并且剩余的元素可以很容易的通过调用 heapq.heappop() 方法得到，

    ```python
    >>> nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
    >>> import heapq
    >>> heap = list(nums)
    >>> heapq.heapify(heap)
    >>> heap
    [-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
    # 如果想要查找最小的 3 个元素，可以使用如下操作
    >>> heapq.heappop(heap)
    -4
    >>> heapq.heappop(heap)
    1
    >>> heapq.heappop(heap)
    2
    ```

    当要查找的元素个数相对比较小的时候，函数 `nlargest()` 和 `nsmallest()` 是很合适的。

    如果仅需要查找唯一的最小或最大（N=1）的元素的话，那么使用 `min()` 和 `max()` 函数会更快些。 

    如果 N 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点 （`sorted(items)[:N]` 或者是 `sorted(items)[-N:]`）
    
    !!! tip
        `heapq` 模块的官方文档里面也详细的介绍了堆数据结构底层的实现细节。

<!-- -------------------------------------------------------------------------- -->
## 05 实现一个优先级队列

!!! question "问题"
    怎样实现一个按优先级排序的队列？ 并且在这个队列上面每次 pop 操作总是返回优先级最高的那个元素
    
??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 06 字典中的键映射多个值

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 07 字典排序

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 08 字典的运算

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 09 查找两字典的相同点

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 10 删除序列相同元素并保持顺序

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 11 命名切片

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 12 序列中出现次数最多的元素

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 13 通过某个关键字排序一个字典列表

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 14 排序不支持原生比较的对象

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 15 通过某个字段将记录分组

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 16 过滤序列元素

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 17 从字典中提取子集

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 18 映射名称到序列元素

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 19 转换并同时计算数据

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 20 合并多个字典或映射

!!! question "问题"

??? done "解决方案"

??? summary "讨论"

<!-- -------------------------------------------------------------------------- -->
## 总结

!!! example "总结"