# 目录

## 第1章 理解高性能Python 
- [ ] 1.1 基本的计算机系统 
- [ ] 1.1.1 计算单元
- [ ] 1.1.2 存储单元 
- [ ] 1.1.3 通信层 
- [ ] 1.2 将基本的元素组装到一起 
- [ ] 1.3 为什么使用Python 

## 第2章 通过性能分析找到瓶颈 
- [ ] 2.1 高效地分析性能 
- [ ] 2.2 Julia集合的介绍 
- [ ] 2.3 计算完整的Julia集合 
- [ ] 2.4 计时的简单方法——打印和修饰 
- [ ] 2.5 用UNIX的time命令进行简单的计时 
- [ ] 2.6 使用cProfile模块 
- [ ] 2.7 用runsnakerun对cProfile的输出进行可视化
- [ ] 2.8 用line_profiler进行逐行分析 
- [ ] 2.9 用memory_profiler诊断内存的用量 
- [ ] 2.10 用heapy调查堆上的对象 
- [ ] 2.11 用dowser实时画出变量的实例 
- [ ] 2.12 用dis模块检查CPython字节码 
- [ ] 2.13 在优化期间进行单元测试保持代码的正确性 
- [ ] 2.14 确保性能分析成功的策略 
- [ ] 2.15 小结
  
## 第3章 列表和元组 
- [ ] 3.1 一个更有效的搜索 
- [ ] 3.2 列表和元组 
- [ ] 3.2.1 动态数组：列表 
- [ ] 3.2.2 静态数组：元组 
- [ ] 3.3 小结 
  
## 第4章 字典和集合 
- [ ] 4.1 字典和集合如何工作 
- [ ] 4.1.1 插入和获取 
- [ ] 4.1.2 删除 
- [ ] 4.1.3 改变大小 
- [ ] 4.1.4 散列函数和熵 
- [ ] 4.2 字典和命名空间 
- [ ] 4.3 小结 
  
## 第5章 迭代器和生成器 
- [ ] 5.1 无穷数列的迭代器 
- [ ] 5.2 生成器的延迟估值 
- [ ] 5.3 小结 
  
## 第6章 矩阵和矢量计算 
- [ ] 6.1 问题介绍 
- [ ] 6.2 Python列表还不够吗 
- [ ] 6.3 内存碎片 
- [ ] 6.3.1 理解perf 
- [ ] 6.3.2 根据perf输出做出抉择 
- [ ] 6.3.3 使用numpy 
- [ ] 6.4 用numpy解决扩散问题 
- [ ] 6.4.1 内存分配和就地操作 
- [ ] 6.4.2 选择优化点：找到需要被修正的地方 
- [ ] 6.5 numexpr：让就地操作更快更简单 
- [ ] 6.6 告诫故事：验证你的“优化”（scipy） 
- [ ] 6.7 小结 
  
## 第7章 编译成C
- [ ] 7.1 可能获得哪种类型的速度提升 
- [ ] 7.2 JIT和AOT编译器的对比 
- [ ] 7.3 为什么类型检查有助代码更快运行 
- [ ] 7.4 使用C编译器 
- [ ] 7.5 复习Julia集的例子 
- [ ] 7.6 Cython 
- [ ] 7.6.1 使用Cython编译纯Python版本 
- [ ] 7.6.2 Cython注解来分析代码块 
- [ ] 7.6.3 增加一些类型注解 
- [ ] 7.7 Shed Skin 
- [ ] 7.7.1 构建扩展模块 
- [ ] 7.7.2 内存拷贝的开销 
- [ ] 7.8 Cython和numpy 
- [ ] 7.9 Numba 
- [ ] 7.10 Pythran 
- [ ] 7.11 PyPy 
- [ ] 7.11.1 垃圾收集的差异
- [ ] 7.11.2 运行PyPy并安装模块
- [ ] 7.12 什么时候使用每种工具 
- [ ] 7.12.1 其他即将出现的项目 
- [ ] 7.12.2 一个图像处理单元（GPU）的注意点 
- [ ] 7.12.3 一个对未来编译器项目的展望 
- [ ] 7.13 外部函数接口 
- [ ] 7.13.1 ctypes 
- [ ] 7.13.2 cffi 
- [ ] 7.13.3 f2py 
- [ ] 7.13.4 CPython模块 
- [ ] 7.14 小结
  
## 第8章 并发
- [ ] 8.1 异步编程介绍 
- [ ] 8.2 串行爬虫 
- [ ] 8.3 gevent 
- [ ] 8.4 tornado 
- [ ] 8.5 AsyncIO 
- [ ] 8.6 数据库的例子
- [ ] 8.7 小结
                     
## 第9章 multiprocessing模块                
- [ ] 9.1 multiprocessing模块综述               
- [ ] 9.2 使用蒙特卡罗方法来估算Pi                
- [ ] 9.3 使用多进程和多线程来估算Pi               
- [ ] 9.3.1 使用Python对象 
- [ ] 9.3.2 并行系统中的随机数 
- [ ] 9.3.3 使用numpy 
- [ ] 9.4 寻找素数 
- [ ] 9.5 使用进程间通信来验证素数 
- [ ] 9.5.1 串行解决方案 
- [ ] 9.5.2 Naïve Pool解决方案 2
- [ ] 9.5.3 Less Naïve Pool解决方案 
- [ ] 9.5.4 使用Manager.Value作为一个标记 
- [ ] 9.5.5 使用Redis作为一个标记 
- [ ] 9.5.6 使用RawValue作为一个标记 
- [ ] 9.5.7 使用mmap作为一个标记 
- [ ] 9.5.8 使用mmap作为一个标记的终极效果 
- [ ] 9.6 用multiprocessing来共享numpy数据 
- [ ] 9.7 同步文件和变量访问 
- [ ] 9.7.1 文件锁 
- [ ] 9.7.2 给Value加锁 
- [ ] 9.8 小结 
  
## 第10章 集群和工作队列
- [ ] 10.1 集群的益处 
- [ ] 10.2 集群的缺陷 
- [ ] 10.2.1 糟糕的集群升级策略造成华尔街损失4.62亿美元 
- [ ] 10.2.2 Skype的24小时全球中断 
- [ ] 10.3 通用的集群设计 
- [ ] 10.4 怎样启动一个集群化的解决方案 
- [ ] 10.5 使用集群时避免痛苦的方法 
- [ ] 10.6 三个集群化解决方案 
- [ ] 10.6.1 为简单的本地集群使用Parallel Python模块 
- [ ] 10.6.2 使用IPython Parallel来支持研究 
- [ ] 10.7 为鲁棒生产集群的NSQ 
- [ ] 10.7.1 队列 
- [ ] 10.7.2 发布者/订阅者
- [ ] 10.7.3 分布式素数计算器 
- [ ] 10.8 看一下其他的集群化工具 
- [ ] 10.9 小结 
  
## 第11章 使用更少的RAM 
- [ ] 11.1 基础类型的对象开销高 
- [ ] 11.2 理解集合中的RAM使用 
- [ ] 11.3 字节和Unicode的对比 
- [ ] 11.4 高效地在RAM中存储许多文本
- [ ] 11.5 使用更少RAM的窍门
- [ ] 11.6 概率数据结构 
- [ ] 11.6.1 使用1字节的Morris计数器来做近似计数 
- [ ] 11.6.2 K最小值 
- [ ] 11.6.3 布隆过滤器 
- [ ] 11.6.4 LogLog计数器 
- [ ] 11.6.5 真实世界的例子 
  
## 第12章 现场教训 
- [ ] 12.1 自适应实验室（Adaptive Lab）的社交媒体分析（SoMA）
- [ ] 12.1.1 自适应实验室（Adaptive Lab）使用的Python 
- [ ] 12.1.2 SoMA的设计 
- [ ] 12.1.3 我们的开发方法论
- [ ] 12.1.4 维护SoMA
- [ ] 12.1.5 对工程师同行的建议 
- [ ] 12.2 使用RadimRehurek.com让深度学习飞翔 
- [ ] 12.2.1 最佳时机 
- [ ] 12.2.2 优化方面的教训 
- [ ] 12.2.3 总结 318
- [ ] 12.3 在Lyst.com的大规模产品化的机器学习 
- [ ] 12.3.1 Python在Lyst的地位 
- [ ] 12.3.2 集群设计 
- [ ] 12.3.3 在快速前进的初创公司中做代码评估 
- [ ] 12.3.4 构建推荐引擎 
- [ ] 12.3.5 报告和监控 
- [ ] 12.3.6 一些建议 
- [ ] 12.4 在Smesh的大规模社交媒体分析
- [ ] 12.4.1 Python在Smesh中的角色
- [ ] 12.4.2 平台 
- [ ] 12.4.3 高性能的实时字符串匹配 
- [ ] 12.4.4 报告、监控、调试和部署 
- [ ] 12.5 PyPy促成了成功的Web和数据处理系统 
- [ ] 12.5.1 先决条件
- [ ] 12.5.2 数据库
- [ ] 12.5.3 Web应用 
- [ ] 12.5.4 OCR和翻译 
- [ ] 12.5.5 任务分发和工作者 
- [ ] 12.5.6 结论 
- [ ] 12.6 在Lanyrd.com中的任务队列
- [ ] 12.6.1 Python在Lanyrd中的角色 
- [ ] 12.6.2 使任务队列变高性能
- [ ] 12.6.3 报告、监控、调试和部署 
- [ ] 12.6.4 对开发者同行的建议 

## 拓展阅读

- [Python高性能编程](https://book.douban.com/subject/27064848/)
