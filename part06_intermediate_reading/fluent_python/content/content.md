# 目录

## 第一部分 序幕

### 第1章 Python 数据模型

??? abstract

- [ ] 1.1 一摞Python风格的纸牌
- [ ] 1.2 如何使用特殊方法

<!-- [ ]  1.2.1 模拟数值类型
  - [ ] 1.2.2 字符串表示形式
  - [ ] 1.2.3 算术运算符
  - [ ] 1.2.4 自定义的布尔值
 -->
- [ ] 1.3 特殊方法一览
- [ ] 1.4 为什么len不是普通方法
- [ ] 1.5 本章小结
- [ ] 1.6 延伸阅读

## 第二部分 数据结构

### 第2章 序列构成的数组

??? abstract

- [ ] 2.1 内置序列类型概览
- [ ] 2.2 列表推导和生成器表达式

<!-- [ ]  2.2.1 列表推导和可读性
  - [ ] 2.2.2 列表推导同filter和map的比较
  - [ ] 2.2.3 笛卡尔积
  - [ ] 2.2.4 生成器表达式 -->

- [ ] 2.3 元组不仅仅是不可变列表

<!-- [ ]  2.3.1 元组和记录
  - [ ] 2.3.2 元组拆包
  - [ ] 2.3.3 嵌套元组拆包
  - [ ] 2.3.4 具名元组
  - [ ] 2.3.5 作为不可变列表的元组 -->

- [ ] 2.4 切片

<!-- [ ]  2.4.1 为什么切片和区间会忽略最后一个元素
  - [ ] 2.4.2 对对象进行切片
  - [ ] 2.4.3 多维切片和省略
  - [ ] 2.4.4 给切片赋值 -->

- [ ] 2.5 对序列使用+和\*

<!-- [ ] - [ ] 建立由列表组成的列表 -->

- [ ] 2.6 序列的增量赋值

<!-- [ ]  一个关于+=的谜题 -->

- [ ] 2.7 list.sort方法和内置函数sorted
- [ ] 2.8 用bisect来管理已排序的序列

<!-- [ ]  2.8.1 用bisect来搜索
  - [ ] 2.8.2 用bisect.insert插入新元素 -->

- [ ] 2.9 当列表不是首选时

<!-- [ ]  2.9.1 数组
  - [ ] 2.9.2 内存视图
  - [ ] 2.9.3 NumPy和SciPy
  - [ ] 2.9.4 双向队列和其它形式的队列 -->

- [ ] 2.10 本章小结
- [ ] 2.11 延伸阅读

### 第3章 字典和集合

??? abstract

- [ ] 3.1 泛映射类型
- [ ] 3.2 字典推导
- [ ] 3.3 常见的映射方法

<!-- [ ]  用setdefault处理找不到的键 -->

- [ ] 3.4 映射的弹性键查询

<!-- [ ]  3.4.1 defaultdict：处理找不到的键的一个选择
  - [ ] 3.4.2 特殊方法\_\_missing\_\_ -->

- [ ] 3.5 字典的变种
- [ ] 3.6 子类化UserDict
- [ ] 3.7 不可变映射类型
- [ ] 3.8 集合论

<!-- [ ]  3.8.1 集合字面量
  - [ ] 3.8.2 集合推导
  - [ ] 3.8.3 集合的操作 -->

- [ ] 3.9 dict和set的背后

<!-- [ ]  3.9.1 一个关于效率的实验
  - [ ] 3.9.2 字典中的散列表
  - [ ] 3.9.3 dict的实现及其导致的结果
  - [ ] 3.9.4 set的实现以及导致的结果 -->

- [ ] 3.10 本章小结
- [ ] 3.11 延伸阅读

### 第4章 文本和字节序列

??? abstract

- [ ] 4.1 字符问题
- [ ] 4.2 字节概要

<!-- [ ]  结构体和内存视图 -->

- [ ] 4.3 基本的编解码器
- [ ] 4.4 了解编解码问题

<!-- [ ]  4.4.1 处理UnicodeEncodeError
  - [ ] 4.4.2 处理UnicodeDecodeError
  - [ ] 4.4.3 使用预期之外的编码加载模块时抛出的SyntaxError
  - [ ] 4.4.4 如何找出字节序列的编码
  - [ ] 4.4.5 BOM：有用的鬼符 -->

- [ ] 4.5 处理文本文件

<!-- [ ]  编码默认值：一团糟 -->

- [ ] 4.6 为了正确比较而规范化Unicode字符串

<!-- [ ]  4.6.1 大小写折叠
  - [ ] 4.6.2 规范化文本匹配实用函数
  - [ ] 4.6.3 极端“规范化”：去掉变音符号 -->

- [ ] 4.7 Unicode文本排序

<!-- [ ]  使用Unicode排序算法排序 -->

- [ ] 4.8 Unicode数据库
- [ ] 4.9 支持字符串和字节序列的双模式API

<!-- [ ]  4.9.1正则表达式中的字符串和字节序列
  - [ ] 4.9.2 os函数中的字符串和字节序列 -->

- [ ] 4.10 本章小结
- [ ] 4.11 延伸阅读

## 第三部分 把函数视作对象

### 第5章 一等函数

??? abstract

- [ ] 5.1 把函数视作对象
- [ ] 5.2 高阶函数

<!-- [ ]  map、filter和reduce的现代替代品 -->

- [ ] 5.3 匿名函数
- [ ] 5.4 可调用函数
- [ ] 5.5 用户定义的可调用类型
- [ ] 5.6 函数内省
- [ ] 5.7 从定位参数到仅限关键字参数
- [ ] 5.8 获取关于参数的信息
- [ ] 5.9 函数注解
- [ ] 5.10 支持函数式编程的信息

<!-- [ ]  5.10.1 operator模块
  - [ ] 5.10.2 使用functools.partial冻结参数 -->

- [ ] 5.12 延伸阅读

### 第6章 使用一等函数实现设计模式

??? abstract

- [ ] 6.1 案例分析：重构“策略”模式

<!-- [ ]  6.1.1 经典的“策略”模式
  - [ ] 6.1.2 使用函数实现“策略”模式
  - [ ] 6.1.3 选择最佳策略：简单的方式
  - [ ] 6.1.4 找出模块中的全部策略 -->

- [ ] 6.2 “命令”模式
- [ ] 6.3 本章小结
- [ ] 6.4 延伸阅读

### 第7章 函数装饰器和闭包

??? abstract

- [ ] 7.1 装饰器基础知识
- [ ] 7.2 Python何时执行装饰器
- [ ] 7.3 使用装饰器改进“策略”模式
- [ ] 7.4 变量作用域规则
- [ ] 7.5 闭包
- [ ] 7.6 nonlocal声明
- [ ] 7.7 实现一个简单的装饰器
- [ ] 7.8 标准库中的装饰器

<!-- [ ]  7.8.1 使用functools.lru_cache作备忘
  - [ ] 7.8.2 单分派泛函数 -->

- [ ] 7.9 叠放装饰器
- [ ] 7.10 参数化装饰器

<!-- [ ]  7.10.1 一个参数化的注册装饰器
  - [ ] 7.10.2 参数化clock装饰器 -->

- [ ] 7.11 本章小结
- [ ] 7.12 延伸阅读

## 第四部分 面向对象惯用法

### 第8章 对象引用、可变性和垃圾回收

??? abstract

- [ ] 8.1 变量不是盒子
- [ ] 8.2 标识、相等性和别名

<!-- [ ]  8.2.1 在==和is之间选择
  - [ ] 8.2.2 元组的相对不可变性 -->

- [ ] 8.3 默认做浅复制

<!-- [ ]  为任意对象做深复制和浅复制 -->

- [ ] 8.4 函数的参数作为引用时

<!-- [ ]  8.4.1 不要使用可变类型作为参数的默认值
  - [ ] 8.4.2 防御可变参数 -->

- [ ] 8.5 del和垃圾回收
- [ ] 8.6 弱引用

<!-- [ ]  8.6.1 WeakValueDictionary简介
  - [ ] 8.6.2 弱引用的局限 -->

- [ ] 8.7 Python对不可变类型施加的把戏
- [ ] 8.9 延伸阅读

### 第9章 符合Python风格的对象

??? abstract

- [ ] 9.1 对象表示形式
- [ ] 9.2 再谈向量类
- [ ] 9.3 备选构造函数
- [ ] 9.4 classmethod与staticmethod
- [ ] 9.5 格式化显示
- [ ] 9.6 可散列的Vector2d
- [ ] 9.7 Python的私有属性和“受保护的”属性
- [ ] 9.8 使用\_\_slots\_\_类属性节省空间
- [ ] 9.9 覆盖类属性
- [ ] 9.10 本章小结
- [ ] 9.11 延伸阅读

### 第10章 序列的修改、散列和切片

??? abstract

- [ ] 10.1 Vector类：用户定义的序列类型
- [ ] 10.2 Vector类第1版：与Vector2d类兼容
- [ ] 10.3 协议和鸭子类型
- [ ] 10.4 Vector类第2版：可切片的序列

<!-- [ ]  10.4.1 切片原理
  - [ ] 10.4.2 能处理切片的\_\_getitem\_\_方法 -->

- [ ] 10.5 Vector类第3版：动态存取属性
- [ ] 10.6 Vector类第4版：散列和快速等值测试
- [ ] 10.7 Vector类第5版：格式化
- [ ] 10.8 本章小结
- [ ] 10.9 延伸阅读

### 第11章 接口：从协议到抽象基类

??? abstract

- [ ] 11.1 Python文件中的接口和协议
- [ ] 11.2 Python喜欢序列 
- [ ] 11.3 使用猴子补丁在运行时实现协议
- [ ] 11.4 Alex Martelli的水禽
- [ ] 11.5 定义抽象基类的子类
- [ ] 11.6 标准库中的抽象基类

<!-- [ ]  11.6.1 collections.abc模块中的抽象基类
  - [ ] 11.6.2 抽象基类的数字塔 -->

- [ ] 11.7 定义并使用一个抽象基类

<!-- [ ]  11.7.1 抽象基类句法详解
  - [ ] 11.7.2 定义Tombola抽象基类的子类
  - [ ] 11.7.3 Tombola的虚拟子类 -->

- [ ] 11.8 Tombola子类的测试方法
- [ ] 11.9 Python使用register的方式
- [ ] 11.10 鹅的行为有可能像鸭子
- [ ] 11.11 本章小结
- [ ] 11.12 延伸阅读

### 第12章 继承的优缺点

??? abstract

- [ ] 12.1 子类化内置类型很麻烦
- [ ] 12.2 多重继承和方法解析顺序
- [ ] 12.3 多重继承的真实应用
- [ ] 12.4 处理多重继承

<!-- [ ]  Tkinter好的、不好的和令人厌恶的方面 -->

- [ ] 12.5 一个现代示例：Django通用视图中的混入
- [ ] 12.6 本章小结
- [ ] 12.7 延伸阅读

### 第13章 正确重载运算符

??? abstract

- [ ] 13.1 运算符重载基础
- [ ] 13.2 一元运算符
- [ ] 13.3 重载向量加法运算符+
- [ ] 13.4 重载标量乘法运算符\*
- [ ] 13.5 众多比较运算符
- [ ] 13.6 增量赋值运算符
- [ ] 13.7 本章小结
- [ ] 13.8 延伸阅读

## 第五部分 控制流程

### 第14章 可迭代的对象、迭代器和生成器

??? abstract

- [ ] 14.1 Sentence类第1版：单词序列
- [ ] 14.2 可迭代对象与迭代器的对比
- [ ] 14.3 Sentence类第2版：典型的迭代器
- [ ] 14.4 Sentence类第3版：生成器函数
- [ ] 14.5 Sentence类第4版：惰性实现
- [ ] 14.6 Sentence类第5版：生成器表达式
- [ ] 14.7 何时使用生成器表达式
- [ ] 14.8 另一个示例：等差数列生成器
- [ ] 14.9 标准库中的生成器函数
- [ ] 14.10 Python3.3中新出现的句法：yield from
- [ ] 14.11 可迭代的归约函数
- [ ] 14.12 深入分析iter函数
- [ ] 14.13 案例分析：在数据库转换工具中使用生成器
- [ ] 14.14 把生成器当成协程
- [ ] 14.15 本章小结
- [ ] 14.16 延伸阅读

### 第15章 上下文管理器和else块

??? abstract

- [ ] 15.1 先做这个，再做那个：if语句之外的else块
- [ ] 15.2 上下文管理器和with块
- [ ] 15.3 contextlib模块中的实用工具
- [ ] 15.4 使用@contextmanager
- [ ] 15.5 本章小结
- [ ] 15.6 延伸阅读

### 第16章 协程

??? abstract

- [ ] 16.1 生成器如何进化成协程
- [ ] 16.2 用作协程的生成器的基本行为
- [ ] 16.3 示例：使用协程计算移动平均值
- [ ] 16.4 预激协程的装饰器
- [ ] 16.5 终止协程和异常处理
- [ ] 16.6 让协程返回值
- [ ] 16.7 使用yield from
- [ ] 16.8 yield from的意义
- [ ] 16.9 使用案例：使用协程做离散事件仿真
<!-- [ ]  16.9.1 离散事件仿真简介
  - [ ] 16.9.2 出租车队运营仿真 -->
- [ ] 16.10 本章小结
- [ ] 16.11 延伸阅读

### 第17章 使用future处理并发

??? abstract

- [ ] 17.1 示例：网络下载的三种风格
<!-- [ ]  17.1.1 依序下载的脚本
  - [ ] 17.1.2 使用concurrent.futures模块下载
  - [ ] 17.1.3 期物在哪里 -->
- [ ] 17.2 阻塞型IO和GIL
- [ ] 17.3 使用concurrent.futures模块启动进程
- [ ] 17.4 实验Executor.map方法
- [ ] 17.5 显示下载进度条并处理错误
<!-- [ ]  17.5.1 flags2系列示例处理错误的方式
  - [ ] 17.5.2 使用futures.as_completed函数
  - [ ] 17.5.3 线程和多进程的替代方案 -->
- [ ] 17.6 本章小结
- [ ] 17.7 延伸阅读

### 第18章 使用asyncio包处理并发

??? abstract

- [ ] 18.1 线程和协程对比
<!-- [ ]  18.1.1 asyncio.Future：故意不阻塞
  - [ ] 18.1.2 从期物、任务和协程中产出 -->
- [ ] 18.2 使用asyncio和aiohttp包下载
- [ ] 18.3 避免阻塞型调用
- [ ] 18.4 改进asyncio下载脚本
<!-- [ ]  18.4.1 改进asyncio.as_completed函数
  - [ ] 18.4.2 使用Executor对象，防止阻塞事件循环 -->
- [ ] 18.5 从回调到期物和协程
- [ ] 18.6 使用asyncio包编写服务器
<!-- [ ]  18.6.1 使用asyncio包编写TCP服务器
  - [ ] 18.6.2 使用aiohttp包编写Web服务器
  - [ ] 18.6.3 更好地支持并发的智能客户端 -->
- [ ] 18.7 本章小结
- [ ] 18.8 延伸阅读

## 第六部分 元编程

### 第19章 动态属性和特性

??? abstract

- [ ] 19.1 使用动态属性转换数据
<!-- [ ]  19.1.1 使用动态属性访问JSON类数据
  - [ ] 19.1.2 处理无效属性名
  - [ ] 19.1.3 使用\_\_new\_\_方法以灵活的方式创建对象
  - [ ] 19.1.4 使用shelve模块调整OSCON数据源的结构
  - [ ] 19.1.5 使用特性获取链接的记录 -->
- [ ] 19.2 使用特性验证属性
<!-- [ ]  19.2.1 LineItem类第1版：表示订单中商品的类
  - [ ] 19.2.2 LineItem类第2版：能验证值的特性 -->
- [ ] 19.3 特性全解析
<!-- [ ]  19.3.1 特性会覆盖实例属性
  - [ ] 19.3.2 特性的文档 -->
- [ ] 19.4 定义一个特性工厂函数
- [ ] 19.5 处理属性删除操作
- [ ] 19.6 处理属性的重要属性和函数
<!-- [ ]  19.6.1 影响属性处理方式的特殊属性
  - [ ] 19.6.2 处理属性的内置函数
  - [ ] 19.6.3 处理属性的特殊方法 -->
- [ ] 19.7 本章小结
- [ ] 19.8 延伸阅读

### 第20章 属性描述符

??? abstract

- [ ] 20.1 描述符示例：验证属性
<!-- [ ]  20.1.1 LineItem类第3版：一个简单的描述符
  - [ ] 20.1.2 LineItem类第4版：自动获取储存属性的名称
  - [ ] 20.1.3 LineItem类第5版：一种新型描述符 -->
- [ ] 20.2 覆盖型与非覆盖型描述符对比
<!-- [ ]  20.2.1 覆盖型描述符
  - [ ] 20.2.2 没有\_\_get\_\_方法的覆盖型描述符
  - [ ] 20.2.3 非覆盖型描述符
  - [ ] 20.2.4 在类中覆盖描述符 -->
- [ ] 20.3 方法是描述符
- [ ] 20.4 描述符用法建议
- [ ] 20.5 描述符的文档字符串和覆盖删除操作
- [ ] 20.6 本章小结
- [ ] 20.7 延伸阅读

### 第21章 类元编程

??? abstract

- [ ] 21.1 类工厂函数
- [ ] 21.2 定制描述符的类装饰器
- [ ] 21.3 导入时和运行时比较
- [ ] 21.4 元类基础知识
- [ ] 21.5 定制描述符的元类
- [ ] 21.6 元类的特殊方法\_\_prepare\_\_
- [ ] 21.7 类作为对象
- [ ] 21.8 本章小结
- [ ] 21.9 延伸阅读

<!-- ## 第一部分 序幕
### 第1章 Python 数据模型
 
## 第二部分 数据结构
### 第2章 序列构成的数组
### 第3章 字典和集合
### 第4章 文本和字节序列
 
## 第三部分 把函数视作对象
### 第5章 一等函数
### 第6章 使用一等函数实现设计模式
### 第7章 函数装饰器和闭包
 
## 第四部分 面向对象惯用法
### 第8章 对象引用、可变性和垃圾回收
### 第9章 符合 Python 风格的对象
### 第10章 序列的修改、散列和切片
### 第11章 接口：从协议到抽象基类
### 第12章 继承的优缺点
### 第13章 正确重载运算符

## 第五部分 控制流程
### 第14章 可迭代的对象、迭代器和生成器
### 第15章 上下文管理器和 else 块
### 第16章 协程
### 第17章 使用期物处理并发
### 第18章 使用 asyncio 包处理并发

## 第六部分 元编程
### 第19章 动态属性和特性
### 第20章 属性描述符
### 第21章 类元编程 -->

## 拓展阅读
- [fluentpython/example-code-2e](https://github.com/fluentpython/example-code-2e)
- [fluentpython/example-code](https://github.com/fluentpython/example-code)